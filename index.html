<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>金猪刷新监控系统</title>
    
    <!-- 外部样式文件 -->
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/mobile.css">
    <link rel="stylesheet" href="css/animations.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>金猪刷新监控系统 <span class="gold-pig">🐷</span></h1>
            <p class="subtitle">监控每条线路的金猪状态，标记击杀后自动开始24小时倒计时</p>
        </header>
        
        <div class="dashboard">
            <div class="controls">
                <div class="panel-title">
                    ℹ️
                    <h2>操作面板 <span class="status-indicator status-active"></span></h2>
                </div>
                
                <div class="instructions">
                    <h3>📖 使用说明</h3>
                    <ul>
                        <li class="desktop-instruction">
                            🖱️
                            <span class="highlight">左键单击线路格子</span> - 标记金猪被击杀（开始24小时倒计时）
                        </li>
                        <li class="desktop-instruction">
                            👆
                            <span class="highlight">右键单击线路格子</span> - 标记金猪被击杀但不知时间
                        </li>
                        <li class="mobile-instruction">
                            📱
                            <span class="highlight">点击线路格子</span> - 标记金猪被击杀（开始24小时倒计时）
                        </li>
                        <li class="mobile-instruction">
                            👆
                            <span class="highlight">快速三连击线路格子</span> - 标记金猪被击杀但不知时间
                        </li>
                        <li>
                            🔄
                            <span class="highlight">双击红色/橙色格子</span> - 取消击杀状态和倒计时
                        </li>
                        <li>
                            🔄
                            倒计时结束后线路自动变为<span class="highlight">绿色</span>可用状态
                        </li>
                        <li>
                            💾
                            所有数据自动保存在浏览器中，关闭浏览器后仍可恢复
                        </li>
                        <li>
                            🕐
                            重新打开浏览器时自动恢复倒计时
                        </li>
                        <li>
                            ⏰
                            <span class="highlight">"只重置倒计时状态"</span> - 清除所有线路标记但保留历史统计
                        </li>
                    </ul>
                </div>
                
                <div class="status-info">
                    <div class="panel-title">
                        🎨
                        <h2>状态说明</h2>
                    </div>
                    <div class="status-item">
                        <div class="status-color status-1"></div>
                        <div>未击杀/可用线路</div>
                    </div>
                    <div class="status-item">
                        <div class="status-color status-2"></div>
                        <div>金猪已被击杀（倒计时中）</div>
                    </div>
                    <div class="status-item">
                        <div class="status-color status-5"></div>
                        <div>金猪已被击杀（时间未知）</div>
                    </div>
                    <div class="status-item">
                        <div class="status-color status-3"></div>
                        <div>金猪已刷新（可再次击杀）</div>
                    </div>
                </div>
                
                <button class="action-btn reset" onclick="resetAll()">
                    🔄 重置所有状态
                </button>
                
                <button class="action-btn reset-timers" onclick="resetTimersOnly()">
                    ⏰ 只重置倒计时状态
                </button>
                
                <button class="action-btn" onclick="toggleTestMode()" id="test-mode-btn">
                    🔬 开启测试模式（10秒倒计时）
                </button>
                
                <button class="action-btn collaboration" onclick="showCollaboration()">
                    🤝 多人协作
                </button>
                
                <button class="action-btn" onclick="window.goldPigApp.uiManager.showDataManagementDialog()">
                    📁 数据管理
                </button>
                
                <div class="notes-container">
                    <label for="notes-input" class="notes-label">
                        📝 备注记录
                    </label>
                    <textarea 
                        id="notes-input" 
                        class="notes-input"
                        placeholder="在这里记录一些备注信息..."
                    ></textarea>
                </div>
            </div>
            
            <div class="flex-container">
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">金猪击杀统计</div>
                        <div class="chart-tabs">
                            <div class="chart-tab active" data-chart="daily">每日击杀</div>
                            <div class="chart-tab" data-chart="total">总击杀</div>
                            <div class="chart-tab" data-chart="hourly">击杀时段</div>
                        </div>
                    </div>
                    <div class="chart-box">
                        <canvas id="stats-chart" width="800" height="300" style="width: 100%; height: 300px; background: rgba(0,0,0,0.1); border-radius: 8px;"></canvas>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="panel-title">
                        📊
                        <h2>状态统计</h2>
                    </div>
                    
                    <div class="stat-cards">
                        <div class="stat-card">
                            <div class="stat-label">总线路数</div>
                            <div class="stat-value" id="total-lines">400</div>
                            <div class="stat-label">当前可用线路</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">已击杀金猪</div>
                            <div class="stat-value" id="killed-count">0</div>
                            <div class="stat-label">倒计时中</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">击杀未知时间</div>
                            <div class="stat-value" id="killed-unknown-count">0</div>
                            <div class="stat-label">时间未知</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">已刷新线路</div>
                            <div class="stat-value" id="refreshed-count">0</div>
                            <div class="stat-label">可再次击杀</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">可用线路</div>
                            <div class="stat-value" id="available-count">400</div>
                            <div class="stat-label">未击杀状态</div>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">今日击杀</div>
                        <div class="stat-value" id="today-count">0</div>
                        <div class="stat-label">最后24小时</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <div class="scroll-hint">
                ⬅️ 向左滑动查看更多线路 ➡️
            </div>
            <table id="line-table">
                <tr>
                    <th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th>
                    <th>I</th><th>J</th><th>K</th><th>L</th><th>M</th><th>N</th><th>O</th><th>P</th>
                    <th>Q</th><th>R</th><th>S</th><th>T</th>
                </tr>
            </table>
        </div>
        
        <footer>
            <p>🔄 系统状态：<span id="status">运行中</span> | 最后更新：<span id="last-update">--:--:--</span></p>
            <p>⚠️ 提示：数据存储在浏览器本地，关闭浏览器后重新打开会恢复倒计时</p>
            <p>👤 制作人：<span class="highlight">Mikogo</span> | 💬 联系QQ：<span class="highlight">1013859513</span></p>
        </footer>
    </div>

    
    <!-- 手机端操作提示 -->
    <div class="mobile-hint">
        点击格子标记击杀，三连击标记不知时间
    </div>

    <!-- 调试信息 -->
    <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; z-index: 1000; font-size: 12px;">
        <div>表格状态: <span id="debug-table-status">检查中...</span></div>
        <div>单元格数: <span id="debug-cell-count">0</span></div>
    </div>

    <!-- 主应用模块脚本 -->
    <script type="module" src="js/app.js"></script>
    
    <!-- 表格生成备用脚本 -->
    <script>
        // 备用表格生成器 - 如果模块加载失败则使用此方法
        function generateTableFallback() {
            console.log('使用备用表格生成器');
            const table = document.getElementById('line-table');
            if (!table) return;
            
            const existingCells = table.querySelectorAll('td[data-line]');
            console.log(`现有单元格: ${existingCells.length}`);
            
            if (existingCells.length >= 400) {
                console.log('表格已完整');
                return;
            }
            
            // 为现有单元格绑定基本事件
            existingCells.forEach(cell => {
                if (!cell.onclick) {
                    cell.addEventListener('click', function() {
                        // 尝试使用主应用的事件处理器，如果不存在则使用备用方式
                        if (window.goldPigApp && window.goldPigApp.eventManager) {
                            const mockEvent = { currentTarget: this };
                            window.goldPigApp.eventManager.handleCellClick(mockEvent);
                        } else {
                            handleCellClickFallback(this);
                        }
                    });
                    
                    cell.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        if (window.goldPigApp && window.goldPigApp.eventManager) {
                            const mockEvent = { currentTarget: this, preventDefault: () => {} };
                            window.goldPigApp.eventManager.handleCellRightClick(mockEvent);
                        } else {
                            handleCellRightClickFallback(this);
                        }
                    });
                    
                    cell.addEventListener('dblclick', function() {
                        if (window.goldPigApp && window.goldPigApp.eventManager) {
                            const mockEvent = { currentTarget: this };
                            window.goldPigApp.eventManager.handleCellDoubleClick(mockEvent);
                        } else {
                            handleCellDoubleClickFallback(this);
                        }
                    });
                }
            });
            
            // 生成剩余的单元格
            let lineNumber = existingCells.length + 1;
            let currentRow = existingCells.length > 0 ? existingCells[existingCells.length - 1].parentElement : null;
            let cellsInCurrentRow = currentRow ? currentRow.children.length : 0;
            
            for (let i = lineNumber; i <= 400; i++) {
                // 如果需要新行
                if (!currentRow || cellsInCurrentRow >= 20) {
                    currentRow = document.createElement('tr');
                    table.appendChild(currentRow);
                    cellsInCurrentRow = 0;
                }
                
                const cell = document.createElement('td');
                cell.textContent = i;
                cell.dataset.line = i;
                
                // 添加定时器显示元素
                const timerDisplay = document.createElement('div');
                timerDisplay.id = `timer-${i}`;
                timerDisplay.className = 'timer-display';
                cell.appendChild(timerDisplay);
                
                // 绑定事件
                cell.addEventListener('click', function() {
                    // 尝试使用主应用的事件处理器，如果不存在则使用备用方式
                    if (window.goldPigApp && window.goldPigApp.eventManager) {
                        // 创建模拟事件
                        const mockEvent = { currentTarget: this };
                        window.goldPigApp.eventManager.handleCellClick(mockEvent);
                    } else {
                        // 备用处理方式
                        handleCellClickFallback(this);
                    }
                });
                
                cell.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    // 尝试使用主应用的事件处理器
                    if (window.goldPigApp && window.goldPigApp.eventManager) {
                        const mockEvent = { currentTarget: this, preventDefault: () => {} };
                        window.goldPigApp.eventManager.handleCellRightClick(mockEvent);
                    } else {
                        // 备用处理方式
                        handleCellRightClickFallback(this);
                    }
                });
                
                cell.addEventListener('dblclick', function() {
                    // 尝试使用主应用的事件处理器
                    if (window.goldPigApp && window.goldPigApp.eventManager) {
                        const mockEvent = { currentTarget: this };
                        window.goldPigApp.eventManager.handleCellDoubleClick(mockEvent);
                    } else {
                        // 备用处理方式
                        handleCellDoubleClickFallback(this);
                    }
                });
                
                currentRow.appendChild(cell);
                cellsInCurrentRow++;
            }
            
            const finalCells = table.querySelectorAll('td[data-line]');
            console.log(`备用生成器完成，总共 ${finalCells.length} 个单元格`);
            
            // 更新调试信息
            const debugCellCount = document.getElementById('debug-cell-count');
            if (debugCellCount) {
                debugCellCount.textContent = finalCells.length;
            }
            
            const debugTableStatus = document.getElementById('debug-table-status');
            if (debugTableStatus) {
                debugTableStatus.textContent = finalCells.length === 400 ? '✅ 正常' : `⚠️ 不完整(${finalCells.length})`;
            }
        }
        
        // 备用事件处理函数 - 优先使用modules中的方法
        function handleCellClickFallback(cell) {
            const lineNumber = cell.dataset.line;
            console.log('备用处理-点击单元格:', lineNumber);
            
            // 优先使用主应用的完整事件处理
            if (window.goldPigApp && window.goldPigApp.eventManager) {
                const mockEvent = { currentTarget: cell };
                window.goldPigApp.eventManager.handleCellClick(mockEvent);
                return;
            }
            
            // 如果已经是击杀状态，则忽略
            if (cell.classList.contains('killed') || cell.classList.contains('killed-unknown')) {
                return;
            }
            
            // 移除刷新状态
            if (cell.classList.contains('refreshed')) {
                cell.classList.remove('refreshed');
            }
            
            // 添加击杀状态
            cell.classList.add('killed');
            
            // 记录击杀时间和状态
            const killTime = new Date().getTime();
            localStorage.setItem(`pigTimer_line-${lineNumber}`, 'killed');
            localStorage.setItem(`pigTimer_killTime-${lineNumber}`, killTime);
            
            // 记录击杀事件 - 使用statsManager的格式
            recordKillEventFallback(lineNumber, killTime);
            
            // 开始倒计时 - 优先使用timerManager
            if (window.goldPigApp && window.goldPigApp.timerManager) {
                window.goldPigApp.timerManager.startTimer(lineNumber, killTime, null, cell, (ln) => {
                    handleTimerCompleteFallback(ln, cell);
                });
            } else {
                startTimerFallback(lineNumber, killTime, cell);
            }
            
            // 更新统计
            updateStatsFallback();
        }
        
        function handleCellRightClickFallback(cell) {
            const lineNumber = cell.dataset.line;
            console.log('备用处理-右击单元格:', lineNumber);
            
            // 优先使用主应用的完整事件处理
            if (window.goldPigApp && window.goldPigApp.eventManager) {
                const mockEvent = { currentTarget: cell, preventDefault: () => {} };
                window.goldPigApp.eventManager.handleCellRightClick(mockEvent);
                return;
            }
            
            // 如果已经是击杀状态，则忽略
            if (cell.classList.contains('killed') || cell.classList.contains('killed-unknown')) {
                return;
            }
            
            // 移除刷新状态
            if (cell.classList.contains('refreshed')) {
                cell.classList.remove('refreshed');
            }
            
            // 添加击杀未知状态
            cell.classList.add('killed-unknown');
            
            // 记录状态（不记录时间）
            localStorage.setItem(`pigTimer_line-${lineNumber}`, 'killed-unknown');
            
            // 记录击杀事件
            const killTime = new Date().getTime();
            recordKillEventFallback(lineNumber, killTime);
            
            // 更新统计
            updateStatsFallback();
        }
        
        function handleCellDoubleClickFallback(cell) {
            const lineNumber = cell.dataset.line;
            console.log('备用处理-双击单元格:', lineNumber);
            
            // 优先使用主应用的完整事件处理
            if (window.goldPigApp && window.goldPigApp.eventManager) {
                const mockEvent = { currentTarget: cell };
                window.goldPigApp.eventManager.handleCellDoubleClick(mockEvent);
                return;
            }
            
            // 移除所有状态
            cell.classList.remove('killed', 'killed-unknown', 'refreshed');
            
            // 清除计时器
            const timerDisplay = document.getElementById(`timer-${lineNumber}`);
            if (timerDisplay) {
                timerDisplay.textContent = '';
            }
            
            // 清除存储 - 使用storageManager的方法或直接清除
            let killTime = null;
            if (window.goldPigApp && window.goldPigApp.storageManager) {
                killTime = window.goldPigApp.storageManager.getKillTime(lineNumber);
                window.goldPigApp.storageManager.removeLineState(lineNumber);
                window.goldPigApp.storageManager.removeKillTime(lineNumber);
            } else {
                killTime = localStorage.getItem(`pigTimer_killTime-${lineNumber}`);
                if (killTime) killTime = parseInt(killTime);
                localStorage.removeItem(`pigTimer_line-${lineNumber}`);
                localStorage.removeItem(`pigTimer_killTime-${lineNumber}`);
            }
            
            // 从击杀事件中移除 - 优先使用statsManager
            if (window.goldPigApp && window.goldPigApp.statsManager) {
                window.goldPigApp.statsManager.removeKillEvent(lineNumber, killTime);
            } else {
                // 备用移除击杀事件
                removeKillEventFallback(lineNumber, killTime);
            }
            
            // 停止倒计时 - 优先使用timerManager
            if (window.goldPigApp && window.goldPigApp.timerManager) {
                window.goldPigApp.timerManager.clearTimer(lineNumber);
            } else if (window.fallbackTimers && window.fallbackTimers[lineNumber]) {
                clearInterval(window.fallbackTimers[lineNumber]);
                delete window.fallbackTimers[lineNumber];
            }
            
            // 更新统计
            updateStatsFallback();
        }
        
        // 备用倒计时函数 - 优先使用timerManager
        function startTimerFallback(lineNumber, killTime, cell) {
            // 如果主应用的timerManager可用，使用它
            if (window.goldPigApp && window.goldPigApp.timerManager) {
                window.goldPigApp.timerManager.startTimer(lineNumber, killTime, null, cell, (ln) => {
                    handleTimerCompleteFallback(ln, cell);
                });
                return;
            }
            
            // 备用倒计时实现
            if (!window.fallbackTimers) {
                window.fallbackTimers = {};
            }
            
            // 如果已有倒计时，先清除
            if (window.fallbackTimers[lineNumber]) {
                clearInterval(window.fallbackTimers[lineNumber]);
            }
            
            const timerDisplay = document.getElementById(`timer-${lineNumber}`);
            if (!timerDisplay) return;
            
            // 检查测试模式
            const testMode = localStorage.getItem('pigTimer_testMode') === 'true';
            const timerDuration = testMode ? 10000 : (24 * 60 * 60 * 1000); // 10秒或24小时
            
            window.fallbackTimers[lineNumber] = setInterval(() => {
                const currentTime = new Date().getTime();
                const elapsed = currentTime - killTime;
                const remaining = timerDuration - elapsed;
                
                if (remaining <= 0) {
                    // 倒计时结束
                    clearInterval(window.fallbackTimers[lineNumber]);
                    delete window.fallbackTimers[lineNumber];
                    
                    handleTimerCompleteFallback(lineNumber, cell);
                } else {
                    // 显示剩余时间
                    const hours = Math.floor(remaining / (60 * 60 * 1000));
                    const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                    const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
                    
                    if (testMode) {
                        timerDisplay.textContent = `${seconds}s`;
                    } else {
                        timerDisplay.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }, 1000);
        }
        
        // 备用倒计时完成处理
        function handleTimerCompleteFallback(lineNumber, cell) {
            // 优先使用tableManager设置刷新状态
            if (window.goldPigApp && window.goldPigApp.tableManager) {
                window.goldPigApp.tableManager.setCellRefreshed(cell, lineNumber);
            } else {
                // 备用设置刷新状态
                cell.classList.remove('killed');
                cell.classList.add('refreshed');
                const timerDisplay = document.getElementById(`timer-${lineNumber}`);
                if (timerDisplay) {
                    timerDisplay.textContent = '';
                }
            }
            
            // 优先使用storageManager更新状态
            if (window.goldPigApp && window.goldPigApp.storageManager) {
                window.goldPigApp.storageManager.setLineState(lineNumber, 'refreshed');
                window.goldPigApp.storageManager.removeKillTime(lineNumber);
            } else {
                localStorage.setItem(`pigTimer_line-${lineNumber}`, 'refreshed');
                localStorage.removeItem(`pigTimer_killTime-${lineNumber}`);
            }
            
            // 优先使用uiManager显示刷新状态
            if (window.goldPigApp && window.goldPigApp.uiManager) {
                window.goldPigApp.uiManager.showRefreshStatus(lineNumber);
            }
            
            // 更新统计
            updateStatsFallback();
        }
        
        // 备用击杀事件记录 - 优先使用statsManager
        function recordKillEventFallback(lineNumber, killTime) {
            if (window.goldPigApp && window.goldPigApp.statsManager) {
                window.goldPigApp.statsManager.recordKillEvent(lineNumber, killTime);
                return;
            }
            
            // 备用记录方式 - 使用与statsManager相同的格式
            let killEvents = [];
            try {
                const stored = localStorage.getItem('killEvents');
                if (stored) {
                    killEvents = JSON.parse(stored);
                }
            } catch (e) {
                console.warn('解析击杀事件记录失败:', e);
                killEvents = [];
            }
            
            // 添加新的击杀事件 - 使用与statsManager相同的格式
            const killEvent = {
                line: parseInt(lineNumber),
                timestamp: killTime
            };
            
            killEvents.push(killEvent);
            
            // 保存更新后的记录
            try {
                localStorage.setItem('killEvents', JSON.stringify(killEvents));
                console.log('备用记录击杀事件:', killEvent);
            } catch (e) {
                console.error('保存击杀事件失败:', e);
            }
        }
        
        // 备用移除击杀事件函数
        function removeKillEventFallback(lineNumber, killTime) {
            try {
                const stored = localStorage.getItem('killEvents');
                if (!stored) return;
                
                let killEvents = JSON.parse(stored);
                const originalLength = killEvents.length;
                
                if (killTime) {
                    // 有击杀时间时，精确匹配 - 使用与statsManager相同的逻辑
                    killEvents = killEvents.filter(event => 
                        !(event.line == lineNumber && Math.abs(event.timestamp - killTime) < 1000)
                    );
                } else {
                    // 没有击杀时间时，移除该线路的最近一次击杀记录
                    for (let i = killEvents.length - 1; i >= 0; i--) {
                        if (killEvents[i].line == lineNumber) {
                            killEvents.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // 只有成功移除事件时才更新存储
                if (killEvents.length < originalLength) {
                    localStorage.setItem('killEvents', JSON.stringify(killEvents));
                    console.log(`备用移除线路 ${lineNumber} 的击杀记录${killTime ? ', 击杀时间: ' + new Date(killTime) : ' (最近一次)'}`);
                } else {
                    console.warn(`备用系统未找到线路 ${lineNumber} 的击杀记录${killTime ? ', 击杀时间: ' + new Date(killTime) : ''}`);
                }
            } catch (e) {
                console.error('备用移除击杀事件失败:', e);
            }
        }
        
        // 备用统计更新函数 - 优先使用statsManager
        function updateStatsFallback() {
            // 优先使用主应用的statsManager
            if (window.goldPigApp && window.goldPigApp.statsManager) {
                window.goldPigApp.statsManager.updateStats();
                return;
            }
            
            // 备用统计更新
            let killedCount = 0;
            let killedUnknownCount = 0;
            let refreshedCount = 0;
            let availableCount = 0;
            
            const cells = document.querySelectorAll('td[data-line]');
            cells.forEach(cell => {
                if (cell.classList.contains('killed')) {
                    killedCount++;
                } else if (cell.classList.contains('killed-unknown')) {
                    killedUnknownCount++;
                } else if (cell.classList.contains('refreshed')) {
                    refreshedCount++;
                } else {
                    availableCount++;
                }
            });
            
            // 计算今日击杀数量
            const todayCount = getTodayKillCountFallback();
            
            // 更新统计显示
            const elements = {
                'killed-count': killedCount,
                'killed-unknown-count': killedUnknownCount,
                'refreshed-count': refreshedCount,
                'available-count': availableCount,
                'total-lines': cells.length,
                'today-count': todayCount
            };
            
            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                }
            });
            
            console.log('备用统计更新:', elements);
        }
        
        // 全局重置函数 - 优先使用主应用的方法
        function resetAll() {
            console.log('执行全局重置');
            
            // 优先使用主应用的重置方法
            if (window.goldPigApp) {
                if (window.goldPigApp.uiManager && !window.goldPigApp.uiManager.showConfirm('确定要重置所有线路状态吗？这将清除所有倒计时和标记状态！')) {
                    return;
                }
                
                if (window.goldPigApp.timerManager) {
                    window.goldPigApp.timerManager.clearAllTimers();
                }
                
                if (window.goldPigApp.storageManager) {
                    window.goldPigApp.storageManager.resetAllData();
                }
                
                if (window.goldPigApp.statsManager) {
                    window.goldPigApp.statsManager.resetAllKillEvents();
                }
                
                if (window.goldPigApp.tableManager) {
                    window.goldPigApp.tableManager.resetAllCells();
                }
                
                if (window.goldPigApp.uiManager) {
                    window.goldPigApp.uiManager.showResetStatus('all');
                }
                
                if (window.goldPigApp.updateStats) {
                    window.goldPigApp.updateStats();
                }
                
                return;
            }
            
            // 备用重置方式
            if (!confirm('确定要重置所有线路状态吗？这将清除所有倒计时和标记状态！')) {
                return;
            }
            
            const cells = document.querySelectorAll('td[data-line]');
            cells.forEach(cell => {
                cell.classList.remove('killed', 'killed-unknown', 'refreshed');
                const timer = cell.querySelector('.timer-display');
                if (timer) timer.textContent = '';
            });
            
            // 清除所有倒计时
            if (window.fallbackTimers) {
                Object.values(window.fallbackTimers).forEach(timerId => clearInterval(timerId));
                window.fallbackTimers = {};
            }
            
            // 清除本地存储
            for (let i = 1; i <= 400; i++) {
                localStorage.removeItem(`pigTimer_line-${i}`);
                localStorage.removeItem(`pigTimer_killTime-${i}`);
            }
            
            // 清除击杀事件
            localStorage.removeItem('killEvents');
            
            // 更新统计
            updateStatsFallback();
            
            console.log('重置完成');
        }
        
        // 仅重置倒计时状态函数 - 优先使用主应用的方法
        function resetTimersOnly() {
            console.log('执行仅重置倒计时');
            
            // 优先使用主应用的重置方法
            if (window.goldPigApp) {
                if (window.goldPigApp.uiManager && !window.goldPigApp.uiManager.showConfirm('确定要重置所有倒计时状态吗？这将清除所有线路的击杀标记，但保留历史统计数据！')) {
                    return;
                }
                
                if (window.goldPigApp.timerManager) {
                    window.goldPigApp.timerManager.clearAllTimers();
                }
                
                if (window.goldPigApp.storageManager) {
                    window.goldPigApp.storageManager.resetAllLineStates();
                }
                
                if (window.goldPigApp.tableManager) {
                    window.goldPigApp.tableManager.resetAllCells();
                }
                
                if (window.goldPigApp.uiManager) {
                    window.goldPigApp.uiManager.showResetStatus('timers');
                }
                
                if (window.goldPigApp.updateStats) {
                    window.goldPigApp.updateStats();
                }
                
                return;
            }
            
            // 备用重置方式
            if (!confirm('确定要重置所有倒计时状态吗？这将清除所有线路的击杀标记，但保留历史统计数据！')) {
                return;
            }
            
            const cells = document.querySelectorAll('td[data-line]');
            cells.forEach(cell => {
                cell.classList.remove('killed', 'killed-unknown', 'refreshed');
                const timer = cell.querySelector('.timer-display');
                if (timer) timer.textContent = '';
            });
            
            // 清除所有倒计时
            if (window.fallbackTimers) {
                Object.values(window.fallbackTimers).forEach(timerId => clearInterval(timerId));
                window.fallbackTimers = {};
            }
            
            // 清除倒计时存储但保留历史
            for (let i = 1; i <= 400; i++) {
                localStorage.removeItem(`pigTimer_line-${i}`);
                localStorage.removeItem(`pigTimer_killTime-${i}`);
            }
            
            // 更新统计
            updateStatsFallback();
            
            console.log('倒计时重置完成');
        }
        
        // 测试模式切换函数 - 优先使用主应用的方法
        function toggleTestMode() {
            console.log('切换测试模式');
            
            // 优先使用主应用的测试模式切换
            if (window.goldPigApp && typeof window.toggleTestMode === 'function') {
                window.toggleTestMode();
                return;
            }
            
            // 备用测试模式切换
            const currentMode = localStorage.getItem('pigTimer_testMode') === 'true';
            const newMode = !currentMode;
            localStorage.setItem('pigTimer_testMode', newMode);
            
            const btn = document.getElementById('test-mode-btn');
            if (btn) {
                btn.textContent = newMode ? '🔬 关闭测试模式' : '🔬 开启测试模式（10秒倒计时）';
            }
            
            console.log('测试模式:', newMode ? '开启' : '关闭');
        }
        
        // 获取今日击杀数量 - 优先使用statsManager
        function getTodayKillCountFallback() {
            // 优先使用主应用的statsManager
            if (window.goldPigApp && window.goldPigApp.statsManager) {
                // 直接调用statsManager的更新方法，它会自动计算今日击杀
                return 0; // 让statsManager处理
            }
            
            try {
                const stored = localStorage.getItem('killEvents');
                if (!stored) return 0;
                
                const killEvents = JSON.parse(stored);
                const now = new Date();
                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
                const todayEnd = todayStart + 24 * 60 * 60 * 1000;
                
                // 统计今天的击杀数量 - 使用与statsManager相同的算法
                const todayKills = killEvents.filter(event => {
                    return event.timestamp >= todayStart && event.timestamp < todayEnd;
                });
                
                return todayKills.length;
            } catch (e) {
                console.warn('获取今日击杀数量失败:', e);
                return 0;
            }
        }
        
        // 延迟检查并在需要时使用备用生成器
        setTimeout(() => {
            const table = document.getElementById('line-table');
            const cells = table ? table.querySelectorAll('td[data-line]') : [];
            
            console.log(`检查表格状态: ${cells.length} 个单元格`);
            
            if (cells.length < 400) {
                console.log('表格不完整，使用备用生成器');
                generateTableFallback();
                
                // 生成完成后恢复状态
                setTimeout(() => {
                    restoreStateFallback();
                }, 500);
            } else {
                console.log('表格已完整');
                // 如果表格完整但主应用未工作，恢复状态
                setTimeout(() => {
                    if (!window.goldPigApp || !window.goldPigApp.initialized) {
                        console.log('主应用未初始化，使用备用状态恢复');
                        restoreStateFallback();
                    }
                }, 1000);
            }
            
            // 检查图表功能
            setTimeout(() => {
                checkChartFunctionality();
            }, 2000);
        }, 3000); // 延迟3秒检查，给主应用足够时间初始化
        
        // 检查图表功能
        function checkChartFunctionality() {
            console.log('检查图表功能...');
            
            // 检查图表元素是否存在
            const canvas = document.getElementById('stats-chart');
            const chartTabs = document.querySelectorAll('.chart-tab');
            
            console.log('Canvas元素:', canvas);
            console.log('图表标签页:', chartTabs.length);
            
            if (!canvas) {
                console.error('Canvas元素不存在');
                return;
            }
            
            if (chartTabs.length === 0) {
                console.error('图表标签页不存在');
                return;
            }
            
            // 检查是否有事件绑定
            let hasEvents = false;
            chartTabs.forEach(tab => {
                if (tab.onclick || tab.addEventListener) {
                    hasEvents = true;
                }
            });
            
            // 如果没有事件绑定，添加备用事件
            if (!hasEvents || (!window.goldPigApp || !window.goldPigApp.initialized)) {
                console.log('添加备用图表事件绑定');
                addFallbackChartEvents();
            }
            
            // 测试图表绘制
            if (typeof window.testChart === 'function') {
                console.log('测试主应用图表功能');
                window.testChart();
            } else {
                console.log('使用备用图表测试');
                testChartFallback();
            }
        }
        
        // 备用图表事件绑定
        function addFallbackChartEvents() {
            const chartTabs = document.querySelectorAll('.chart-tab');
            
            chartTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    console.log('备用图表标签页点击:', this.dataset.chart);
                    
                    // 更新活动状态
                    chartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 尝试使用主应用的图表切换
                    if (typeof window.switchChart === 'function') {
                        window.switchChart(this.dataset.chart);
                    } else {
                        // 备用图表显示
                        renderChartFallback(this.dataset.chart);
                    }
                });
            });
            
            console.log('备用图表事件绑定完成');
        }
        
        // 备用图表渲染
        function renderChartFallback(chartType) {
            console.log('备用图表渲染:', chartType);
            
            const canvas = document.getElementById('stats-chart');
            if (!canvas) {
                console.error('Canvas元素不存在');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('无法获取Canvas上下文');
                return;
            }
            
            try {
                // 设置Canvas尺寸
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                // 清除画布
                ctx.clearRect(0, 0, rect.width, rect.height);
                
                // 绘制简单的占位图表
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fillRect(0, 0, rect.width, rect.height);
                
                ctx.fillStyle = '#f1c40f';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${getChartTitle(chartType)}`, rect.width / 2, rect.height / 2 - 20);
                
                ctx.fillStyle = '#ecf0f1';
                ctx.font = '14px Arial';
                ctx.fillText('图表功能正在加载中...', rect.width / 2, rect.height / 2 + 20);
                
                // 尝试获取实际数据
                if (window.goldPigApp && window.goldPigApp.statsManager) {
                    try {
                        drawSimpleChart(ctx, rect, chartType, window.goldPigApp.statsManager);
                    } catch (dataError) {
                        console.warn('获取图表数据失败:', dataError);
                    }
                }
                
                console.log('备用图表渲染完成');
            } catch (error) {
                console.error('备用图表渲染失败:', error);
            }
        }
        
        // 获取图表标题
        function getChartTitle(chartType) {
            switch (chartType) {
                case 'daily': return '每日击杀趋势';
                case 'total': return '总击杀统计';
                case 'hourly': return '击杀时段分析';
                default: return '击杀统计';
            }
        }
        
        // 绘制简单图表
        function drawSimpleChart(ctx, rect, chartType, statsManager) {
            if (chartType === 'daily') {
                const data = statsManager.getDailyKillData(7);
                drawSimpleLineChart(ctx, rect, data);
            } else if (chartType === 'hourly') {
                const data = statsManager.getHourlyKillData(24);
                drawSimpleBarChart(ctx, rect, data);
            } else {
                const data = statsManager.getDailyKillData(7);
                drawSimpleBarChart(ctx, rect, data);
            }
        }
        
        // 绘制简单折线图
        function drawSimpleLineChart(ctx, rect, chartData) {
            const padding = 40;
            const chartWidth = rect.width - padding * 2;
            const chartHeight = rect.height - padding * 2;
            const maxValue = Math.max(...chartData.data, 1);
            
            // 清除画布
            ctx.clearRect(0, 0, rect.width, rect.height);
            
            // 绘制背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, rect.height - padding);
            ctx.lineTo(rect.width - padding, rect.height - padding);
            ctx.stroke();
            
            // 绘制数据点和折线
            if (chartData.data.length > 1) {
                const stepX = chartWidth / (chartData.data.length - 1);
                
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                chartData.data.forEach((value, index) => {
                    const x = padding + stepX * index;
                    const y = rect.height - padding - (value / maxValue) * chartHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // 绘制数据点
                    ctx.fillStyle = '#3498db';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                ctx.stroke();
            }
            
            // 绘制标题
            ctx.fillStyle = '#f1c40f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('每日击杀趋势', rect.width / 2, 25);
        }
        
        // 绘制简单柱状图
        function drawSimpleBarChart(ctx, rect, chartData) {
            const padding = 40;
            const chartWidth = rect.width - padding * 2;
            const chartHeight = rect.height - padding * 2;
            const maxValue = Math.max(...chartData.data, 1);
            const barWidth = chartWidth / chartData.data.length * 0.8;
            
            // 清除画布
            ctx.clearRect(0, 0, rect.width, rect.height);
            
            // 绘制背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, rect.height - padding);
            ctx.lineTo(rect.width - padding, rect.height - padding);
            ctx.stroke();
            
            // 绘制柱状图
            chartData.data.forEach((value, index) => {
                const x = padding + (chartWidth / chartData.data.length) * index + (chartWidth / chartData.data.length - barWidth) / 2;
                const barHeight = (value / maxValue) * chartHeight;
                const y = rect.height - padding - barHeight;
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // 绘制数值
                if (value > 0) {
                    ctx.fillStyle = '#ecf0f1';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(value.toString(), x + barWidth / 2, y - 5);
                }
            });
            
            // 绘制标题
            ctx.fillStyle = '#f1c40f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('击杀统计', rect.width / 2, 25);
        }
        
        // 备用图表测试
        function testChartFallback() {
            console.log('开始备用图表测试');
            
            const canvas = document.getElementById('stats-chart');
            if (!canvas) {
                console.error('Canvas元素不存在');
                return false;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('无法获取Canvas上下文');
                return false;
            }
            
            try {
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                // 绘制测试图案
                ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                ctx.fillRect(0, 0, rect.width, rect.height);
                
                ctx.fillStyle = '#f1c40f';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('图表功能正常', rect.width / 2, rect.height / 2);
                
                console.log('备用图表测试完成');
                return true;
            } catch (error) {
                console.error('备用图表测试失败:', error);
                return false;
            }
        }
        
        // 立即更新一次统计（确保今日击杀数量正确显示）
        setTimeout(() => {
            if (typeof updateStatsFallback === 'function') {
                updateStatsFallback();
                console.log('页面加载完成，更新统计');
            }
        }, 1000);
        
        // 备用状态恢复函数
        function restoreStateFallback() {
            console.log('开始恢复状态');
            const cells = document.querySelectorAll('td[data-line]');
            
            cells.forEach(cell => {
                const lineNumber = cell.dataset.line;
                const savedState = localStorage.getItem(`pigTimer_line-${lineNumber}`);
                const killTime = localStorage.getItem(`pigTimer_killTime-${lineNumber}`);
                
                if (savedState) {
                    if (savedState === 'killed' && killTime) {
                        cell.classList.add('killed');
                        const killTimeNum = parseInt(killTime);
                        const currentTime = new Date().getTime();
                        const testMode = localStorage.getItem('pigTimer_testMode') === 'true';
                        const timerDuration = testMode ? 10000 : (24 * 60 * 60 * 1000);
                        const elapsed = currentTime - killTimeNum;
                        
                        if (elapsed < timerDuration) {
                            // 继续倒计时
                            startTimerFallback(lineNumber, killTimeNum, cell);
                        } else {
                            // 时间已到，设为刷新状态
                            cell.classList.remove('killed');
                            cell.classList.add('refreshed');
                            localStorage.setItem(`pigTimer_line-${lineNumber}`, 'refreshed');
                        }
                    } else if (savedState === 'killed-unknown') {
                        cell.classList.add('killed-unknown');
                    } else if (savedState === 'refreshed') {
                        cell.classList.add('refreshed');
                    }
                }
            });
            
            // 更新统计
            updateStatsFallback();
            console.log('状态恢复完成');
            
            // 确保页面加载时也更新今日击杀数量
            setTimeout(updateStatsFallback, 1000);
        }
    </script>
    
    <!-- 调试脚本 -->
    <script>
        // 延迟检查表格状态
        setTimeout(() => {
            const table = document.getElementById('line-table');
            const cells = table ? table.querySelectorAll('td[data-line]') : [];
            
            document.getElementById('debug-table-status').textContent = 
                table ? (cells.length > 0 ? '✅ 正常' : '⚠️ 空表格') : '❌ 未找到';
            document.getElementById('debug-cell-count').textContent = cells.length;
            
            if (cells.length === 0) {
                console.error('表格生成失败，检查控制台错误');
            }
        }, 2000);
    </script>
</body>
</html>